<!DOCTYPE html>
<html>
<head>
    <title>üî¨ Simple Tournament Check</title>
    <style>
        body { font-family: monospace; background: #001122; color: #00ddff; padding: 20px; }
        button { background: #00ddff; color: #001122; border: none; padding: 8px 15px; margin: 5px; border-radius: 4px; cursor: pointer; }
        .success { color: #00ff88; }
        .error { color: #ff4444; }
        .warning { color: #ffaa00; }
        #log { background: #000; padding: 15px; height: 300px; overflow-y: auto; border: 1px solid #333; margin: 15px 0; font-size: 12px; }
    </style>
</head>
<body>
    <h1>üî¨ Simple Tournament State Check</h1>
    
    <button onclick="checkRawState()">Check Raw Tournament State</button>
    <button onclick="tryDifferentId()">Try Tournament ID 2</button>
    <button onclick="testSimpleStart()">Test Simple Start Call</button>

    <div id="log"></div>

    <script src="https://cdn.jsdelivr.net/npm/web3@4.2.2/dist/web3.min.js"></script>
    <script>
        const web3 = new Web3('https://testnet.dplabs-internal.com');
        const CONTRACT_ADDRESS = '0x454064eA4517A80b0388EEeFFFBf2Efb85a86061';

        function log(message, type = 'info') {
            const logDiv = document.getElementById('log');
            const timestamp = new Date().toLocaleTimeString();
            const className = type === 'error' ? 'error' : type === 'success' ? 'success' : type === 'warning' ? 'warning' : '';
            logDiv.innerHTML += `<span class="${className}">${timestamp}: ${message}</span><br>`;
            logDiv.scrollTop = logDiv.scrollHeight;
            console.log(message);
        }

        async function checkRawState() {
            try {
                log('üîç Checking raw tournament state...');
                
                // Minimal ABI just for getTournamentInfo
                const abi = [{
                    "inputs": [{"name": "_tournamentId", "type": "uint256"}],
                    "name": "getTournamentInfo",
                    "outputs": [
                        {"name": "entryFee", "type": "uint256"},
                        {"name": "startTime", "type": "uint256"},
                        {"name": "endTime", "type": "uint256"},
                        {"name": "prizePool", "type": "uint256"},
                        {"name": "isActive", "type": "bool"},
                        {"name": "isFinished", "type": "bool"},
                        {"name": "participantCount", "type": "uint256"}
                    ],
                    "stateMutability": "view",
                    "type": "function"
                }];
                
                const contract = new web3.eth.Contract(abi, CONTRACT_ADDRESS);
                const info = await contract.methods.getTournamentInfo(1).call();
                
                log('üìã Tournament 1 Raw Data:', 'success');
                log(`   Entry Fee: ${info.entryFee} wei (${web3.utils.fromWei(info.entryFee.toString(), 'ether')} PHRS)`);
                log(`   Start Time: ${info.startTime.toString()} (${info.startTime.toString() === '0' ? 'Never started' : new Date(Number(info.startTime) * 1000).toLocaleString()})`);
                log(`   End Time: ${info.endTime.toString()}`);
                log(`   Prize Pool: ${info.prizePool.toString()} wei`);
                log(`   Is Active: ${info.isActive}`);
                log(`   Is Finished: ${info.isFinished}`);
                log(`   Participants: ${info.participantCount.toString()}`);
                
                // Analysis
                if (info.startTime.toString() === '0') {
                    log('‚úÖ Tournament has never been started - should be able to start it', 'success');
                } else if (info.isActive) {
                    log('‚ùå Tournament is already ACTIVE - cannot start again!', 'error');
                    log('üí° Try using a different tournament ID (e.g., 2)', 'warning');
                } else if (info.isFinished) {
                    log('‚ùå Tournament is FINISHED - cannot start again!', 'error');
                    log('üí° Try using a different tournament ID (e.g., 2)', 'warning');
                }
                
            } catch (error) {
                log(`‚ùå Raw state check failed: ${error.message}`, 'error');
            }
        }

        async function tryDifferentId() {
            try {
                log('üîç Checking tournament ID 2...');
                
                const abi = [{
                    "inputs": [{"name": "_tournamentId", "type": "uint256"}],
                    "name": "getTournamentInfo",
                    "outputs": [
                        {"name": "entryFee", "type": "uint256"},
                        {"name": "startTime", "type": "uint256"},
                        {"name": "endTime", "type": "uint256"},
                        {"name": "prizePool", "type": "uint256"},
                        {"name": "isActive", "type": "bool"},
                        {"name": "isFinished", "type": "bool"},
                        {"name": "participantCount", "type": "uint256"}
                    ],
                    "stateMutability": "view",
                    "type": "function"
                }];
                
                const contract = new web3.eth.Contract(abi, CONTRACT_ADDRESS);
                const info = await contract.methods.getTournamentInfo(2).call();
                
                log('üìã Tournament 2 State:', 'success');
                log(`   Start Time: ${info.startTime.toString()} ${info.startTime.toString() === '0' ? '(Never started)' : ''}`);
                log(`   Is Active: ${info.isActive}`);
                log(`   Is Finished: ${info.isFinished}`);
                
                if (info.startTime.toString() === '0') {
                    log('‚úÖ Tournament 2 is available! Try starting tournament with ID=2', 'success');
                } else {
                    log('‚ö†Ô∏è Tournament 2 also has been used', 'warning');
                }
                
            } catch (error) {
                log(`‚ùå Tournament 2 check failed: ${error.message}`, 'error');
            }
        }

        async function testSimpleStart() {
            try {
                log('üß™ Testing simple start call via MetaMask...');
                
                if (!window.ethereum) {
                    throw new Error('MetaMask not found');
                }
                
                const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                const account = accounts[0];
                
                log(`üîó Connected: ${account}`);
                
                const metaMaskWeb3 = new Web3(window.ethereum);
                
                // Test with tournament ID 2 (should be unused)
                const tournamentId = 2;
                const entryFee = metaMaskWeb3.utils.toWei('0.005', 'ether');
                const duration = 3600;
                
                log(`üìã Testing startTournament(${tournamentId}, ${metaMaskWeb3.utils.fromWei(entryFee, 'ether')} PHRS, ${duration}s)`);
                
                // Minimal ABI for startTournament
                const abi = [{
                    "inputs": [
                        {"name": "_tournamentId", "type": "uint256"},
                        {"name": "_entryFee", "type": "uint256"},
                        {"name": "_duration", "type": "uint256"}
                    ],
                    "name": "startTournament",
                    "outputs": [],
                    "stateMutability": "nonpayable",
                    "type": "function"
                }];
                
                const contract = new metaMaskWeb3.eth.Contract(abi, CONTRACT_ADDRESS);
                
                // Try gas estimation first
                try {
                    const gasEstimate = await contract.methods
                        .startTournament(tournamentId, entryFee, duration)
                        .estimateGas({ from: account });
                    
                    log(`‚úÖ Gas estimation SUCCESS: ${gasEstimate}`, 'success');
                    log('üí° Call should work! Attempting actual transaction...', 'success');
                    
                    // Try actual call
                    const tx = await contract.methods
                        .startTournament(tournamentId, entryFee, duration)
                        .send({
                            from: account,
                            gas: Math.round(gasEstimate * 1.2)
                        });
                    
                    log(`üéâ SUCCESS! Tournament ${tournamentId} started! TX: ${tx.transactionHash}`, 'success');
                    
                } catch (gasError) {
                    log(`‚ùå Gas estimation failed: ${gasError.message}`, 'error');
                    
                    if (gasError.message.includes('revert')) {
                        log('üí° Call would revert - possible reasons:', 'warning');
                        log('   1. Tournament ID already used', 'warning');
                        log('   2. Contract has specific restrictions', 'warning');
                        log('   3. Try tournament ID 3, 4, 5...', 'warning');
                    }
                }
                
            } catch (error) {
                log(`‚ùå Simple start test failed: ${error.message}`, 'error');
            }
        }

        // Auto-start check
        log('üöÄ Simple Tournament Check loaded');
        log('üí° Click buttons to diagnose why startTournament is failing');
    </script>
</body>
</html>