<!DOCTYPE html>
<html>
<head>
    <title>üî¨ Diagnose Contract Revert</title>
    <style>
        body { font-family: monospace; background: #001122; color: #00ddff; padding: 20px; }
        button { background: #00ddff; color: #001122; border: none; padding: 8px 15px; margin: 5px; border-radius: 4px; cursor: pointer; }
        .success { color: #00ff88; }
        .error { color: #ff4444; }
        .warning { color: #ffaa00; }
        #log { background: #000; padding: 15px; height: 400px; overflow-y: auto; border: 1px solid #333; margin: 15px 0; font-size: 12px; }
        .section { border: 1px solid #00ddff; padding: 15px; margin: 15px 0; border-radius: 8px; }
    </style>
</head>
<body>
    <h1>üî¨ Contract Revert Diagnosis</h1>
    
    <div class="section">
        <h3>Connection</h3>
        <button onclick="connect()">Connect Wallet</button>
        <div id="connection-status">Not connected</div>
    </div>

    <div class="section">
        <h3>Contract Owner Check</h3>
        <button onclick="checkOwner()">Check Contract Owner</button>
        <button onclick="checkPermissions()">Check Admin Permissions</button>
    </div>

    <div class="section">
        <h3>Tournament State Analysis</h3>
        <button onclick="checkTournamentState()">Check Tournament 1 State</button>
        <button onclick="checkAllTournaments()">Check All Tournaments</button>
    </div>

    <div class="section">
        <h3>Function Call Simulation</h3>
        <button onclick="simulateStartTournament()">Simulate startTournament</button>
        <button onclick="testCallStatic()">Test Call Static</button>
    </div>

    <div id="log"></div>

    <script src="https://cdn.jsdelivr.net/npm/web3@4.2.2/dist/web3.min.js"></script>
    <script>
        const CONFIG = {
            CONTRACT_ADDRESS: '0x454064eA4517A80b0388EEeFFFBf2Efb85a86061',
            RPC_URL: 'https://testnet.dplabs-internal.com',
            ADMIN_ADDRESS: '0x59F74eD82A08F80cff5D7E8055f6a24A18595F64'
        };

        const CONTRACT_ABI = [
            {"inputs": [], "name": "owner", "outputs": [{"name": "", "type": "address"}], "stateMutability": "view", "type": "function"},
            {"inputs": [], "name": "tournamentCounter", "outputs": [{"name": "", "type": "uint256"}], "stateMutability": "view", "type": "function"},
            {"inputs": [{"name": "_tournamentId", "type": "uint256"}], "name": "getTournamentInfo", "outputs": [{"name": "entryFee", "type": "uint256"}, {"name": "startTime", "type": "uint256"}, {"name": "endTime", "type": "uint256"}, {"name": "prizePool", "type": "uint256"}, {"name": "isActive", "type": "bool"}, {"name": "isFinished", "type": "bool"}, {"name": "participantCount", "type": "uint256"}], "stateMutability": "view", "type": "function"},
            {"inputs": [{"name": "_tournamentId", "type": "uint256"}, {"name": "_entryFee", "type": "uint256"}, {"name": "_duration", "type": "uint256"}], "name": "startTournament", "outputs": [], "stateMutability": "nonpayable", "type": "function"}
        ];

        let web3 = null;
        let contract = null;
        let account = null;

        function log(message, type = 'info') {
            const logDiv = document.getElementById('log');
            const timestamp = new Date().toLocaleTimeString();
            const className = type === 'error' ? 'error' : type === 'success' ? 'success' : type === 'warning' ? 'warning' : '';
            logDiv.innerHTML += `<span class="${className}">${timestamp}: ${message}</span><br>`;
            logDiv.scrollTop = logDiv.scrollHeight;
            console.log(message);
        }

        async function connect() {
            try {
                log('üîó Connecting wallet...');
                
                if (!window.ethereum) throw new Error('MetaMask not found');

                const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                web3 = new Web3(window.ethereum);
                account = accounts[0];
                
                contract = new web3.eth.Contract(CONTRACT_ABI, CONFIG.CONTRACT_ADDRESS);
                
                document.getElementById('connection-status').innerHTML = `‚úÖ Connected: ${account.substring(0,8)}...`;
                log(`‚úÖ Connected: ${account}`, 'success');
                
                if (account.toLowerCase() === CONFIG.ADMIN_ADDRESS.toLowerCase()) {
                    log('üëë Admin account detected!', 'success');
                } else {
                    log('‚ö†Ô∏è Not admin account', 'warning');
                }
                
            } catch (error) {
                log(`‚ùå Connection failed: ${error.message}`, 'error');
            }
        }

        async function checkOwner() {
            try {
                log('üëë Checking contract owner...');
                
                if (!contract) throw new Error('Connect wallet first');
                
                const owner = await contract.methods.owner().call();
                log(`üìã Contract owner: ${owner}`, 'success');
                log(`üìã Your address: ${account}`);
                log(`üìã Config admin: ${CONFIG.ADMIN_ADDRESS}`);
                
                if (owner.toLowerCase() === account.toLowerCase()) {
                    log('‚úÖ You ARE the contract owner!', 'success');
                } else {
                    log('‚ùå You are NOT the contract owner!', 'error');
                    log('üí° This is likely why startTournament is reverting', 'warning');
                }
                
                if (owner.toLowerCase() === CONFIG.ADMIN_ADDRESS.toLowerCase()) {
                    log('‚úÖ Config admin matches contract owner', 'success');
                } else {
                    log('‚ùå Config admin does NOT match contract owner!', 'error');
                    log(`üí° Update tournament-config.js ADMIN_ADDRESS to: ${owner}`, 'warning');
                }
                
            } catch (error) {
                log(`‚ùå Owner check failed: ${error.message}`, 'error');
            }
        }

        async function checkPermissions() {
            try {
                log('üîê Checking admin permissions...');
                
                const owner = await contract.methods.owner().call();
                const isOwner = owner.toLowerCase() === account.toLowerCase();
                
                log(`Owner check: ${isOwner ? 'PASS' : 'FAIL'}`, isOwner ? 'success' : 'error');
                
                if (!isOwner) {
                    log('‚ùå Main issue: You do not have owner permissions', 'error');
                    log(`üí° Contract owner is: ${owner}`, 'warning');
                    log('üí° You need to use the owner account to start tournaments', 'warning');
                }
                
            } catch (error) {
                log(`‚ùå Permission check failed: ${error.message}`, 'error');
            }
        }

        async function checkTournamentState() {
            try {
                log('üìä Checking tournament 1 state...');
                
                if (!contract) throw new Error('Connect wallet first');
                
                const info = await contract.methods.getTournamentInfo(1).call();
                
                log('üìã Tournament 1 Info:', 'success');
                log(`   Entry Fee: ${web3.utils.fromWei(info.entryFee, 'ether')} PHRS`);
                log(`   Start Time: ${info.startTime} (${new Date(info.startTime * 1000).toLocaleString()})`);
                log(`   End Time: ${info.endTime} (${new Date(info.endTime * 1000).toLocaleString()})`);
                log(`   Prize Pool: ${web3.utils.fromWei(info.prizePool, 'ether')} PHRS`);
                log(`   Is Active: ${info.isActive}`);
                log(`   Is Finished: ${info.isFinished}`);
                log(`   Participants: ${info.participantCount}`);
                
                const now = Math.floor(Date.now() / 1000);
                log(`   Current Time: ${now} (${new Date().toLocaleString()})`);
                
                // Analyze state
                if (info.startTime > 0) {
                    if (info.isActive && !info.isFinished) {
                        log('‚úÖ Tournament is ACTIVE and running', 'success');
                    } else if (info.isFinished) {
                        log('‚ö†Ô∏è Tournament is FINISHED', 'warning');
                    } else if (info.startTime > 0 && !info.isActive) {
                        log('‚ö†Ô∏è Tournament was created but is INACTIVE', 'warning');
                    }
                } else {
                    log('‚úÖ Tournament 1 has never been started (startTime = 0)', 'success');
                    log('üí° This should be fine for starting new tournament', 'success');
                }
                
            } catch (error) {
                log(`‚ùå Tournament state check failed: ${error.message}`, 'error');
            }
        }

        async function checkAllTournaments() {
            try {
                log('üìä Checking all tournaments...');
                
                const counter = await contract.methods.tournamentCounter().call();
                log(`üìã Tournament counter: ${counter}`, 'success');
                
                for (let i = 1; i <= Math.min(counter, 5); i++) {
                    try {
                        const info = await contract.methods.getTournamentInfo(i).call();
                        log(`Tournament ${i}: Active=${info.isActive}, Finished=${info.isFinished}, Participants=${info.participantCount}`);
                    } catch (e) {
                        log(`Tournament ${i}: Error - ${e.message}`, 'error');
                    }
                }
                
            } catch (error) {
                log(`‚ùå All tournaments check failed: ${error.message}`, 'error');
            }
        }

        async function simulateStartTournament() {
            try {
                log('üß™ Simulating startTournament call...');
                
                if (!contract) throw new Error('Connect wallet first');
                
                const tournamentId = 1;
                const entryFee = web3.utils.toWei('0.005', 'ether');
                const duration = 3600;
                
                log(`üìã Parameters: ID=${tournamentId}, Fee=${web3.utils.fromWei(entryFee, 'ether')} PHRS, Duration=${duration}s`);
                
                // Try estimating gas first
                try {
                    const gasEstimate = await contract.methods
                        .startTournament(tournamentId, entryFee, duration)
                        .estimateGas({ from: account });
                    
                    log(`‚úÖ Gas estimate succeeded: ${gasEstimate}`, 'success');
                    log('üí° This means the call should work!', 'success');
                    
                } catch (gasError) {
                    log(`‚ùå Gas estimation failed: ${gasError.message}`, 'error');
                    
                    // Try to get more details
                    if (gasError.message.includes('revert')) {
                        log('üí° Call would revert. Checking reasons...', 'warning');
                        
                        // Check owner again
                        const owner = await contract.methods.owner().call();
                        if (owner.toLowerCase() !== account.toLowerCase()) {
                            log(`‚ùå REASON: You are not the owner! Owner is ${owner}`, 'error');
                        }
                        
                        // Check tournament state
                        const info = await contract.methods.getTournamentInfo(tournamentId).call();
                        if (info.isActive) {
                            log(`‚ùå REASON: Tournament ${tournamentId} is already active!`, 'error');
                        }
                        
                    } else {
                        log('üí° Gas estimation failed for other reasons', 'warning');
                    }
                }
                
            } catch (error) {
                log(`‚ùå Simulation failed: ${error.message}`, 'error');
            }
        }

        async function testCallStatic() {
            try {
                log('üî¨ Testing static call...');
                
                const directWeb3 = new Web3(CONFIG.RPC_URL);
                const directContract = new directWeb3.eth.Contract(CONTRACT_ABI, CONFIG.CONTRACT_ADDRESS);
                
                const tournamentId = 1;
                const entryFee = directWeb3.utils.toWei('0.005', 'ether');
                const duration = 3600;
                
                // Encode the function call
                const encoded = directContract.methods.startTournament(tournamentId, entryFee, duration).encodeABI();
                
                log(`üìã Encoded call: ${encoded.substring(0, 50)}...`);
                
                // Try static call
                try {
                    const result = await directWeb3.eth.call({
                        to: CONFIG.CONTRACT_ADDRESS,
                        data: encoded,
                        from: account
                    });
                    
                    log(`‚úÖ Static call succeeded: ${result}`, 'success');
                    
                } catch (staticError) {
                    log(`‚ùå Static call failed: ${staticError.message}`, 'error');
                    
                    if (staticError.message.includes('revert')) {
                        log('üí° Call reverts - checking possible reasons:', 'warning');
                        log('   1. Not contract owner', 'warning');
                        log('   2. Tournament already exists/active', 'warning');
                        log('   3. Invalid parameters', 'warning');
                        log('   4. Contract paused or has other restrictions', 'warning');
                    }
                }
                
            } catch (error) {
                log(`‚ùå Static call test failed: ${error.message}`, 'error');
            }
        }

        // Auto-load
        log('üî¨ Contract Revert Diagnosis Tool loaded');
        log('üí° Connect wallet and run diagnostics to find revert cause');
    </script>
</body>
</html>