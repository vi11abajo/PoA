<!DOCTYPE html>
<html>
<head>
    <title>Circuit Breaker Bypass Methods</title>
    <style>
        body { font-family: monospace; background: #001122; color: #00ddff; padding: 20px; }
        button { background: #00ddff; color: #001122; border: none; padding: 8px 15px; margin: 5px; border-radius: 4px; cursor: pointer; }
        .success { color: #00ff88; }
        .error { color: #ff4444; }
        .warning { color: #ffaa00; }
        #log { background: #000; padding: 15px; height: 400px; overflow-y: auto; border: 1px solid #333; margin: 15px 0; font-size: 12px; }
        .method { border: 1px solid #00ddff; padding: 15px; margin: 15px 0; border-radius: 8px; }
    </style>
</head>
<body>
    <h1>üîì Circuit Breaker Bypass Methods</h1>
    
    <div class="method">
        <h3>Method 1: Reset MetaMask State</h3>
        <button onclick="resetMetaMaskState()">Clear MetaMask Cache</button>
        <p>Clears MetaMask's internal blacklist cache</p>
    </div>

    <div class="method">
        <h3>Method 2: Use Different Provider</h3>
        <button onclick="tryOKXWallet()">Switch to OKX Wallet</button>
        <button onclick="tryDirectProvider()">Use Direct RPC Provider</button>
        <p>Bypass MetaMask entirely</p>
    </div>

    <div class="method">
        <h3>Method 3: Manual Transaction Crafting</h3>
        <button onclick="craftManualTransaction()">Craft Raw Transaction</button>
        <p>Create transaction manually without using contract interface</p>
    </div>

    <div class="method">
        <h3>Method 4: Alternative Contract Call</h3>
        <button onclick="useAlternativeABI()">Try Minimal ABI</button>
        <button onclick="useFallbackMethod()">Use Fallback Function</button>
        <p>Different ways to interact with contract</p>
    </div>

    <div id="log"></div>

    <script src="https://cdn.jsdelivr.net/npm/web3@4.2.2/dist/web3.min.js"></script>
    <script>
        const CONFIG = {
            CONTRACT_ADDRESS: '0x454064eA4517A80b0388EEeFFFBf2Efb85a86061',
            RPC_URL: 'https://testnet.dplabs-internal.com',
            CHAIN_ID: 688688,
            ENTRY_FEE: '0.005'
        };

        function log(message, type = 'info') {
            const logDiv = document.getElementById('log');
            const timestamp = new Date().toLocaleTimeString();
            const className = type === 'error' ? 'error' : type === 'success' ? 'success' : type === 'warning' ? 'warning' : '';
            logDiv.innerHTML += `<span class="${className}">${timestamp}: ${message}</span><br>`;
            logDiv.scrollTop = logDiv.scrollHeight;
            console.log(message);
        }

        async function resetMetaMaskState() {
            try {
                log('üîÑ Attempting MetaMask state reset...');
                
                // –ü–æ–ø—ã—Ç–∫–∞ –æ—á–∏—Å—Ç–∏—Ç—å —Å–æ—Å—Ç–æ—è–Ω–∏–µ —á–µ—Ä–µ–∑ –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ —Å–µ—Ç–µ–π
                await window.ethereum.request({
                    method: 'wallet_switchEthereumChain',
                    params: [{ chainId: '0x1' }] // Ethereum mainnet
                });
                
                await new Promise(resolve => setTimeout(resolve, 2000));
                
                // –í–æ–∑–≤—Ä–∞—Ç –Ω–∞ Pharos Testnet
                await window.ethereum.request({
                    method: 'wallet_switchEthereumChain',
                    params: [{ chainId: '0xa7c5c' }] // Pharos Testnet
                });
                
                log('‚úÖ Network switching completed', 'success');
                log('üí° Now try the registration again in main tournament page', 'warning');
                
            } catch (error) {
                log(`‚ùå Reset failed: ${error.message}`, 'error');
                log('üí° Manual reset: MetaMask ‚Üí Settings ‚Üí Advanced ‚Üí Reset Account', 'warning');
            }
        }

        async function tryOKXWallet() {
            try {
                log('üîç Checking for OKX Wallet...');
                
                if (typeof window.okexchain !== 'undefined') {
                    log('‚úÖ OKX Wallet detected!', 'success');
                    
                    const accounts = await window.okexchain.request({ method: 'eth_requestAccounts' });
                    const web3 = new Web3(window.okexchain);
                    
                    log(`Connected to OKX: ${accounts[0].substring(0,8)}...`, 'success');
                    log('üí° Try registration with OKX wallet now', 'success');
                    
                } else if (typeof window.ethereum !== 'undefined' && window.ethereum.isOkxWallet) {
                    log('‚úÖ OKX Wallet detected (via ethereum)!', 'success');
                    log('üí° Switch to OKX in wallet selector', 'warning');
                    
                } else {
                    log('‚ùå OKX Wallet not installed', 'error');
                    log('üí° Install OKX Wallet extension as alternative', 'warning');
                }
                
            } catch (error) {
                log(`‚ùå OKX test failed: ${error.message}`, 'error');
            }
        }

        async function tryDirectProvider() {
            try {
                log('üîç Testing direct provider transaction...');
                log('‚ö†Ô∏è This method cannot sign transactions (no private key)', 'warning');
                log('üí° But it can test if RPC accepts the transaction format', 'warning');
                
                const web3 = new Web3(CONFIG.RPC_URL);
                
                // –¢–µ—Å—Ç–∏—Ä—É–µ–º —Ç–æ–ª—å–∫–æ —Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏–µ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
                const contract = new web3.eth.Contract([{
                    "inputs": [{"name": "_tournamentId", "type": "uint256"}, {"name": "_playerName", "type": "bytes32"}],
                    "name": "registerForTournament",
                    "outputs": [],
                    "stateMutability": "payable",
                    "type": "function"
                }], CONFIG.CONTRACT_ADDRESS);
                
                const playerNameBytes32 = web3.utils.padRight(web3.utils.toHex('TestPlayer'), 64);
                
                // –§–æ—Ä–º–∏—Ä—É–µ–º –¥–∞–Ω–Ω—ã–µ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
                const txData = contract.methods.registerForTournament(1, playerNameBytes32).encodeABI();
                
                log(`‚úÖ Transaction data generated: ${txData.substring(0, 20)}...`, 'success');
                log('üí° RPC can process this transaction format', 'success');
                
            } catch (error) {
                log(`‚ùå Direct provider test failed: ${error.message}`, 'error');
            }
        }

        async function craftManualTransaction() {
            try {
                log('üõ† Crafting manual transaction...');
                
                if (!window.ethereum) throw new Error('No wallet found');
                
                const web3 = new Web3(window.ethereum);
                const accounts = await window.ethereum.request({ method: 'eth_accounts' });
                
                if (accounts.length === 0) {
                    await window.ethereum.request({ method: 'eth_requestAccounts' });
                    const newAccounts = await window.ethereum.request({ method: 'eth_accounts' });
                    accounts.push(...newAccounts);
                }
                
                const account = accounts[0];
                
                // –§—É–Ω–∫—Ü–∏—è registerForTournament(uint256,bytes32)
                const methodId = '0x' + web3.utils.keccak256('registerForTournament(uint256,bytes32)').substring(2, 10);
                
                // –ü–∞—Ä–∞–º–µ—Ç—Ä—ã: tournamentId = 1, playerName = "TestPlayer"
                const tournamentId = web3.utils.padLeft(web3.utils.numberToHex(1), 64);
                const playerNameBytes32 = web3.utils.padRight(web3.utils.toHex('TestPlayer'), 64);
                
                const data = methodId + tournamentId.substring(2) + playerNameBytes32.substring(2);
                
                log(`üîß Method ID: ${methodId}`);
                log(`üîß Transaction data: ${data.substring(0, 50)}...`);
                
                // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º raw transaction
                const txParams = {
                    from: account,
                    to: CONFIG.CONTRACT_ADDRESS,
                    value: web3.utils.toWei(CONFIG.ENTRY_FEE, 'ether'),
                    data: data,
                    gas: '0x30D40' // 200000
                };
                
                log('üöÄ Sending raw transaction...');
                
                const txHash = await window.ethereum.request({
                    method: 'eth_sendTransaction',
                    params: [txParams]
                });
                
                log(`‚úÖ MANUAL TRANSACTION SUCCESS! TX: ${txHash}`, 'success');
                log('üéâ Circuit breaker bypassed with raw transaction!', 'success');
                
            } catch (error) {
                log(`‚ùå Manual transaction failed: ${error.message}`, 'error');
                
                if (error.message.includes('circuit breaker')) {
                    log('üö® Circuit breaker still blocking raw transactions', 'error');
                }
            }
        }

        async function useAlternativeABI() {
            try {
                log('üß™ Testing with minimal ABI...');
                
                const web3 = new Web3(window.ethereum);
                const accounts = await web3.eth.getAccounts();
                
                if (accounts.length === 0) throw new Error('Connect wallet first');
                
                // –ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è ABI —Ç–æ–ª—å–∫–æ —Å –Ω—É–∂–Ω–æ–π —Ñ—É–Ω–∫—Ü–∏–µ–π
                const minimalABI = [{
                    "name": "registerForTournament",
                    "type": "function",
                    "inputs": [
                        {"name": "tournamentId", "type": "uint256"},
                        {"name": "playerName", "type": "bytes32"}
                    ],
                    "payable": true
                }];
                
                const contract = new web3.eth.Contract(minimalABI, CONFIG.CONTRACT_ADDRESS);
                const playerNameBytes32 = web3.utils.padRight(web3.utils.toHex('TestPlayer'), 64);
                
                log('üéØ Attempting registration with minimal ABI...');
                
                const tx = await contract.methods.registerForTournament(1, playerNameBytes32).send({
                    from: accounts[0],
                    value: web3.utils.toWei(CONFIG.ENTRY_FEE, 'ether'),
                    gas: 200000
                });
                
                log(`‚úÖ MINIMAL ABI SUCCESS! TX: ${tx.transactionHash}`, 'success');
                
            } catch (error) {
                log(`‚ùå Minimal ABI failed: ${error.message}`, 'error');
            }
        }

        async function useFallbackMethod() {
            try {
                log('üß™ Testing fallback method call...');
                
                const web3 = new Web3(window.ethereum);
                const accounts = await web3.eth.getAccounts();
                
                if (accounts.length === 0) throw new Error('Connect wallet first');
                
                // –ü—ã—Ç–∞–µ–º—Å—è –≤—ã–∑–≤–∞—Ç—å —á–µ—Ä–µ–∑ –ø—Ä–æ—Å—Ç—É—é —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é —Å data
                const methodSignature = web3.utils.keccak256('registerForTournament(uint256,bytes32)').substring(0, 10);
                const encodedParams = web3.eth.abi.encodeParameters(
                    ['uint256', 'bytes32'], 
                    [1, web3.utils.padRight(web3.utils.toHex('TestPlayer'), 64)]
                );
                
                const data = methodSignature + encodedParams.substring(2);
                
                log('üîß Using fallback method with encoded data...');
                
                const tx = await web3.eth.sendTransaction({
                    from: accounts[0],
                    to: CONFIG.CONTRACT_ADDRESS,
                    value: web3.utils.toWei(CONFIG.ENTRY_FEE, 'ether'),
                    data: data,
                    gas: 200000
                });
                
                log(`‚úÖ FALLBACK METHOD SUCCESS! TX: ${tx.transactionHash}`, 'success');
                
            } catch (error) {
                log(`‚ùå Fallback method failed: ${error.message}`, 'error');
            }
        }

        // –ê–≤—Ç–æ–∑–∞–ø—É—Å–∫
        log('üöÄ Circuit Breaker Bypass Tool loaded');
        log('üí° Try different methods to bypass MetaMask circuit breaker');
        log('‚ö†Ô∏è Method 1 (Reset State) is usually most effective');
    </script>
</body>
</html>