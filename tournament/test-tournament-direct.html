<!DOCTYPE html>
<html>
<head>
    <title>Direct Tournament Contract Test</title>
    <style>
        body { font-family: monospace; background: #001122; color: #00ddff; padding: 20px; }
        button { background: #00ddff; color: #001122; border: none; padding: 8px 15px; margin: 5px; border-radius: 4px; cursor: pointer; }
        .success { color: #00ff88; }
        .error { color: #ff4444; }
        .warning { color: #ffaa00; }
        #log { background: #000; padding: 15px; height: 400px; overflow-y: auto; border: 1px solid #333; margin: 15px 0; font-size: 12px; }
        .test-section { border: 1px solid #00ddff; padding: 15px; margin: 15px 0; border-radius: 8px; }
    </style>
</head>
<body>
    <h1>üî¨ Direct Tournament Contract Test</h1>
    
    <div class="test-section">
        <h3>Step 1: Connection Test</h3>
        <button onclick="connectWallet()">Connect MetaMask</button>
        <button onclick="testDirectRPC()">Test Direct RPC</button>
        <div id="connection-status">Not connected</div>
    </div>

    <div class="test-section">
        <h3>Step 2: Read-only Tests</h3>
        <button onclick="testTournamentCounter()">Test tournamentCounter()</button>
        <button onclick="testGetTournamentInfo()">Test getTournamentInfo(1)</button>
        <button onclick="testIsPlayerRegistered()">Test isPlayerRegistered()</button>
    </div>

    <div class="test-section">
        <h3>Step 3: Write Tests (MetaMask Required)</h3>
        <button onclick="testRegisterForTournament()">Test Registration</button>
        <button onclick="testStartTournament()">Test Start Tournament (Admin)</button>
        <div>Entry Fee: 0.005 PHRS | Tournament ID: 1</div>
    </div>

    <div id="log"></div>

    <script src="https://cdn.jsdelivr.net/npm/web3@4.2.2/dist/web3.min.js"></script>
    <script>
        const CONFIG = {
            CONTRACT_ADDRESS: '0x454064eA4517A80b0388EEeFFFBf2Efb85a86061',
            RPC_URL: 'https://testnet.dplabs-internal.com',
            CHAIN_ID: 688688,
            ENTRY_FEE: '0.005'
        };

        // –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π ABI —Ç–æ–ª—å–∫–æ –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
        const TOURNAMENT_ABI = [
            {"inputs": [], "name": "tournamentCounter", "outputs": [{"name": "", "type": "uint256"}], "stateMutability": "view", "type": "function"},
            {"inputs": [{"name": "_tournamentId", "type": "uint256"}], "name": "getTournamentInfo", "outputs": [{"name": "entryFee", "type": "uint256"}, {"name": "startTime", "type": "uint256"}, {"name": "endTime", "type": "uint256"}, {"name": "prizePool", "type": "uint256"}, {"name": "isActive", "type": "bool"}, {"name": "isFinished", "type": "bool"}, {"name": "participantCount", "type": "uint256"}], "stateMutability": "view", "type": "function"},
            {"inputs": [{"name": "_tournamentId", "type": "uint256"}, {"name": "_player", "type": "address"}], "name": "isPlayerRegistered", "outputs": [{"name": "", "type": "bool"}], "stateMutability": "view", "type": "function"},
            {"inputs": [{"name": "_tournamentId", "type": "uint256"}, {"name": "_playerName", "type": "bytes32"}], "name": "registerForTournament", "outputs": [], "stateMutability": "payable", "type": "function"},
            {"inputs": [{"name": "_tournamentId", "type": "uint256"}, {"name": "_entryFee", "type": "uint256"}, {"name": "_duration", "type": "uint256"}], "name": "startTournament", "outputs": [], "stateMutability": "nonpayable", "type": "function"}
        ];

        let web3 = null;
        let contract = null;
        let account = null;

        function log(message, type = 'info') {
            const logDiv = document.getElementById('log');
            const timestamp = new Date().toLocaleTimeString();
            const className = type === 'error' ? 'error' : type === 'success' ? 'success' : type === 'warning' ? 'warning' : '';
            logDiv.innerHTML += `<span class="${className}">${timestamp}: ${message}</span><br>`;
            logDiv.scrollTop = logDiv.scrollHeight;
            console.log(message);
        }

        async function connectWallet() {
            try {
                log('üîó Connecting to MetaMask...');
                
                if (!window.ethereum) {
                    throw new Error('MetaMask not found');
                }

                const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                web3 = new Web3(window.ethereum);
                account = accounts[0];
                
                const chainId = await web3.eth.getChainId();
                log(`Connected: ${account.substring(0,8)}...`);
                log(`Chain ID: ${chainId} (expected: ${CONFIG.CHAIN_ID})`);
                
                if (chainId !== CONFIG.CHAIN_ID) {
                    log('‚ö†Ô∏è Wrong network! Switching to Pharos Testnet...', 'warning');
                    await switchNetwork();
                }
                
                contract = new web3.eth.Contract(TOURNAMENT_ABI, CONFIG.CONTRACT_ADDRESS);
                
                document.getElementById('connection-status').innerHTML = `‚úÖ Connected: ${account.substring(0,8)}...`;
                log('‚úÖ MetaMask connection successful', 'success');
                
            } catch (error) {
                log(`‚ùå Connection failed: ${error.message}`, 'error');
                document.getElementById('connection-status').innerHTML = `‚ùå Connection failed`;
            }
        }

        async function switchNetwork() {
            try {
                await window.ethereum.request({
                    method: 'wallet_switchEthereumChain',
                    params: [{ chainId: `0x${CONFIG.CHAIN_ID.toString(16)}` }]
                });
            } catch (switchError) {
                if (switchError.code === 4902) {
                    await window.ethereum.request({
                        method: 'wallet_addEthereumChain',
                        params: [{
                            chainId: `0x${CONFIG.CHAIN_ID.toString(16)}`,
                            chainName: 'Pharos Testnet',
                            rpcUrls: [CONFIG.RPC_URL],
                            nativeCurrency: { name: 'PHRS', symbol: 'PHRS', decimals: 18 }
                        }]
                    });
                }
            }
        }

        async function testDirectRPC() {
            try {
                log('üß™ Testing direct RPC connection...');
                
                const directWeb3 = new Web3(CONFIG.RPC_URL);
                const directContract = new directWeb3.eth.Contract(TOURNAMENT_ABI, CONFIG.CONTRACT_ADDRESS);
                
                const counter = await directContract.methods.tournamentCounter().call();
                log(`‚úÖ Direct RPC SUCCESS! Tournament counter: ${counter}`, 'success');
                log('üí° Contract is accessible via direct RPC', 'success');
                
            } catch (error) {
                log(`‚ùå Direct RPC failed: ${error.message}`, 'error');
            }
        }

        async function testTournamentCounter() {
            try {
                log('üß™ Testing tournamentCounter() via MetaMask...');
                
                if (!contract) {
                    throw new Error('Connect wallet first');
                }
                
                const counter = await contract.methods.tournamentCounter().call();
                log(`‚úÖ MetaMask call SUCCESS! Tournament counter: ${counter}`, 'success');
                
            } catch (error) {
                log(`‚ùå tournamentCounter() failed: ${error.message}`, 'error');
                
                if (error.message.includes('circuit breaker')) {
                    log('üö® CIRCUIT BREAKER detected on read-only call!', 'error');
                    log('üí° This suggests MetaMask has blacklisted this contract', 'warning');
                }
            }
        }

        async function testGetTournamentInfo() {
            try {
                log('üß™ Testing getTournamentInfo(1)...');
                
                if (!contract) throw new Error('Connect wallet first');
                
                const info = await contract.methods.getTournamentInfo(1).call();
                log(`‚úÖ Tournament info: entryFee=${info.entryFee}, active=${info.isActive}, participants=${info.participantCount}`, 'success');
                
            } catch (error) {
                log(`‚ùå getTournamentInfo() failed: ${error.message}`, 'error');
            }
        }

        async function testIsPlayerRegistered() {
            try {
                log('üß™ Testing isPlayerRegistered()...');
                
                if (!contract || !account) throw new Error('Connect wallet first');
                
                const isRegistered = await contract.methods.isPlayerRegistered(1, account).call();
                log(`‚úÖ Player ${account.substring(0,8)}... registered: ${isRegistered}`, 'success');
                
            } catch (error) {
                log(`‚ùå isPlayerRegistered() failed: ${error.message}`, 'error');
            }
        }

        async function testRegisterForTournament() {
            try {
                log('üß™ Testing tournament registration...');
                
                if (!contract || !account) throw new Error('Connect wallet first');
                
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º –±–∞–ª–∞–Ω—Å
                const balance = await web3.eth.getBalance(account);
                const balanceEth = web3.utils.fromWei(balance, 'ether');
                log(`üí∞ Account balance: ${balanceEth} PHRS`);
                
                if (parseFloat(balanceEth) < parseFloat(CONFIG.ENTRY_FEE)) {
                    throw new Error(`Insufficient balance. Need ${CONFIG.ENTRY_FEE} PHRS, have ${balanceEth} PHRS`);
                }
                
                // –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –∏–º—è –∏–≥—Ä–æ–∫–∞ –≤ bytes32
                const playerName = `TestPlayer${Date.now()}`;
                const playerNameBytes32 = web3.utils.padRight(web3.utils.toHex(playerName), 64);
                
                log(`üéØ Attempting registration with name: ${playerName}`);
                log(`üíé Entry fee: ${CONFIG.ENTRY_FEE} PHRS`);
                
                // –ü—ã—Ç–∞–µ–º—Å—è –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞—Ç—å—Å—è
                const entryFeeWei = web3.utils.toWei(CONFIG.ENTRY_FEE, 'ether');
                
                const tx = await contract.methods.registerForTournament(1, playerNameBytes32).send({
                    from: account,
                    value: entryFeeWei,
                    gas: 200000
                });
                
                log(`‚úÖ REGISTRATION SUCCESS! TX: ${tx.transactionHash}`, 'success');
                log('üéâ Circuit breaker is NOT blocking transactions!', 'success');
                
            } catch (error) {
                log(`‚ùå Registration failed: ${error.message}`, 'error');
                
                if (error.message.includes('circuit breaker')) {
                    log('üö® CIRCUIT BREAKER active on write transactions', 'error');
                    log('üí° Possible solutions:', 'warning');
                    log('   1. Wait 15-30 minutes and try again', 'warning');
                    log('   2. Use different wallet (OKX instead of MetaMask)', 'warning');
                    log('   3. Clear MetaMask cache or reset account', 'warning');
                } else if (error.message.includes('revert')) {
                    log('üí° Transaction reverted - this is normal if tournament not started', 'warning');
                } else if (error.message.includes('User denied')) {
                    log('üí° User cancelled transaction', 'warning');
                }
            }
        }

        async function testStartTournament() {
            try {
                log('üß™ Testing start tournament (admin function)...');
                
                if (!contract || !account) throw new Error('Connect wallet first');
                
                const entryFeeWei = web3.utils.toWei(CONFIG.ENTRY_FEE, 'ether');
                const duration = 3600; // 1 hour
                
                log(`üöÄ Starting tournament 1 with fee ${CONFIG.ENTRY_FEE} PHRS, duration 1 hour`);
                
                const tx = await contract.methods.startTournament(1, entryFeeWei, duration).send({
                    from: account,
                    gas: 150000
                });
                
                log(`‚úÖ TOURNAMENT STARTED! TX: ${tx.transactionHash}`, 'success');
                
            } catch (error) {
                log(`‚ùå Start tournament failed: ${error.message}`, 'error');
                
                if (error.message.includes('Ownable')) {
                    log('üí° Only contract owner can start tournaments', 'warning');
                } else if (error.message.includes('already started')) {
                    log('üí° Tournament already started', 'warning');
                }
            }
        }

        // –ê–≤—Ç–æ–∑–∞–ø—É—Å–∫
        log('üöÄ Test page loaded. Connect wallet and run tests.');
        log(`üìç Contract: ${CONFIG.CONTRACT_ADDRESS}`);
        log(`üåê Network: Pharos Testnet (${CONFIG.CHAIN_ID})`);
    </script>
</body>
</html>