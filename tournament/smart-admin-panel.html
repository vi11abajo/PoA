<!DOCTYPE html>
<html>
<head>
    <title>üß† Smart Admin Panel</title>
    <style>
        body { font-family: monospace; background: #001122; color: #00ddff; padding: 20px; }
        button { background: #00ddff; color: #001122; border: none; padding: 10px 15px; margin: 5px; border-radius: 4px; cursor: pointer; font-weight: bold; }
        .big-button { font-size: 18px; padding: 20px 30px; background: #00ff88; color: #001122; margin: 10px; }
        .generate-btn { background: #ffaa00; color: #001122; }
        .danger { background: #ff4444; color: white; }
        .success { color: #00ff88; }
        .error { color: #ff4444; }
        .warning { color: #ffaa00; }
        input, select { background: #001122; color: #00ddff; border: 1px solid #00ddff; padding: 8px; margin: 5px; border-radius: 4px; }
        #log { background: #000; padding: 15px; height: 350px; overflow-y: auto; border: 1px solid #333; margin: 15px 0; font-size: 12px; }
        .section { border: 1px solid #00ddff; padding: 20px; margin: 15px 0; border-radius: 8px; }
        .id-display { background: #003366; padding: 15px; border-radius: 8px; margin: 10px 0; border: 2px solid #00ff88; }
        .strategy { margin: 10px 0; }
    </style>
</head>
<body>
    <h1>üß† Smart Tournament Admin Panel</h1>
    <p>Automatic Tournament ID generation with multiple strategies</p>
    
    <div class="section">
        <h3>üîó Connection</h3>
        <button onclick="connectAdmin()">Connect Admin Wallet</button>
        <div id="connection-status">Not connected</div>
    </div>

    <div class="section">
        <h3>üé≤ Tournament ID Generation</h3>
        
        <div class="strategy">
            <label><strong>ID Strategy:</strong></label>
            <select id="id-strategy">
                <option value="sequential">Sequential (2, 3, 4...)</option>
                <option value="random">Random (ABC123 ‚Üí number)</option>
                <option value="timestamp">Timestamp-based</option>
            </select>
        </div>
        
        <button class="generate-btn" onclick="generateTournamentId()">üé≤ Generate New Tournament ID</button>
        <button onclick="checkIdAvailability()">üîç Check Availability</button>
        
        <div id="generated-id" class="id-display" style="display:none;">
            <strong>Generated Tournament ID:</strong>
            <div id="id-display" style="font-size: 20px; color: #00ff88;"></div>
            <div id="id-info" style="font-size: 12px; color: #66ccff; margin-top: 5px;"></div>
        </div>
    </div>

    <div class="section">
        <h3>üöÄ Tournament Controls</h3>
        
        <div style="margin: 10px 0;">
            <label>Entry Fee (PHRS):</label>
            <input type="number" id="entry-fee" value="0.005" step="0.001" min="0">
        </div>
        
        <div style="margin: 10px 0;">
            <label>Duration:</label>
            <select id="duration">
                <option value="3600">1 Hour</option>
                <option value="7200">2 Hours</option>
                <option value="21600">6 Hours</option>
                <option value="86400">24 Hours</option>
            </select>
        </div>
        
        <button class="big-button" onclick="smartStartTournament()">üöÄ AUTO-START TOURNAMENT</button>
        <button onclick="checkRunningTournaments()">üìä Check Running Tournaments</button>
    </div>

    <div class="section">
        <h3>üõ† Manual Controls</h3>
        
        <div style="margin: 10px 0;">
            <label>Manual Tournament ID:</label>
            <input type="number" id="manual-id" placeholder="Enter specific ID">
            <button onclick="startWithManualId()">Start with Manual ID</button>
        </div>
        
        <button class="danger" onclick="endTournament()">üèÅ END TOURNAMENT</button>
    </div>

    <div id="log"></div>

    <script src="https://cdn.jsdelivr.net/npm/web3@4.2.2/dist/web3.min.js"></script>
    <script src="tournament-manager.js"></script>
    <script>
        let connected = false;
        let tournamentManager = new TournamentManager();
        let currentGeneratedId = null;

        function log(message, type = 'info') {
            const logDiv = document.getElementById('log');
            const timestamp = new Date().toLocaleTimeString();
            const className = type === 'error' ? 'error' : type === 'success' ? 'success' : type === 'warning' ? 'warning' : '';
            logDiv.innerHTML += `<span class="${className}">${timestamp}: ${message}</span><br>`;
            logDiv.scrollTop = logDiv.scrollHeight;
        }

        async function connectAdmin() {
            try {
                log('üëë Connecting admin wallet...');
                
                if (!window.ethereum) {
                    throw new Error('MetaMask not found');
                }

                const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                
                const walletConnector = {
                    web3: new Web3(window.ethereum),
                    account: accounts[0],
                    connected: true
                };
                
                const chainId = await walletConnector.web3.eth.getChainId();
                if (chainId !== 688688) {
                    log('‚ö†Ô∏è Wrong network, switching to Pharos Testnet...', 'warning');
                    await switchNetwork();
                }
                
                const success = await tournamentManager.connect(walletConnector);
                
                if (success) {
                    connected = true;
                    document.getElementById('connection-status').innerHTML = `‚úÖ Connected: ${accounts[0].substring(0,8)}...`;
                    log(`‚úÖ Admin connected: ${accounts[0]}`, 'success');
                } else {
                    throw new Error('Failed to connect tournament manager');
                }
                
            } catch (error) {
                log(`‚ùå Connection failed: ${error.message}`, 'error');
            }
        }

        async function switchNetwork() {
            try {
                await window.ethereum.request({
                    method: 'wallet_switchEthereumChain',
                    params: [{ chainId: '0xa7c5c' }]
                });
            } catch (switchError) {
                if (switchError.code === 4902) {
                    await window.ethereum.request({
                        method: 'wallet_addEthereumChain',
                        params: [{
                            chainId: '0xa7c5c',
                            chainName: 'Pharos Testnet',
                            rpcUrls: ['https://testnet.dplabs-internal.com'],
                            nativeCurrency: { name: 'PHRS', symbol: 'PHRS', decimals: 18 }
                        }]
                    });
                }
            }
        }

        async function generateTournamentId() {
            try {
                if (!connected) {
                    await connectAdmin();
                    if (!connected) return;
                }

                const strategy = document.getElementById('id-strategy').value;
                log(`üé≤ Generating Tournament ID with strategy: ${strategy}...`);
                
                currentGeneratedId = await tournamentManager.generateSmartTournamentId(strategy);
                
                document.getElementById('generated-id').style.display = 'block';
                document.getElementById('id-display').textContent = currentGeneratedId;
                
                let infoText = '';
                switch (strategy) {
                    case 'sequential':
                        infoText = 'Next available sequential ID';
                        break;
                    case 'random':
                        infoText = '6-character random code converted to number';
                        break;
                    case 'timestamp':
                        infoText = 'Timestamp-based unique ID';
                        break;
                }
                document.getElementById('id-info').textContent = infoText;
                
                log(`‚úÖ Generated Tournament ID: ${currentGeneratedId}`, 'success');
                
                // Auto-check availability
                await checkIdAvailability();
                
            } catch (error) {
                log(`‚ùå ID generation failed: ${error.message}`, 'error');
            }
        }

        async function checkIdAvailability() {
            try {
                if (!currentGeneratedId) {
                    log('‚ö†Ô∏è No ID generated yet. Click "Generate New Tournament ID" first.', 'warning');
                    return;
                }

                log(`üîç Checking availability of ID ${currentGeneratedId}...`);
                
                const info = await tournamentManager.getTournamentInfo(currentGeneratedId);
                
                if (info.startTime === 0 || info.startTime === '0') {
                    log(`‚úÖ Tournament ID ${currentGeneratedId} is AVAILABLE!`, 'success');
                    document.getElementById('id-info').innerHTML += '<br><span style="color: #00ff88;">‚úÖ AVAILABLE</span>';
                } else {
                    log(`‚ùå Tournament ID ${currentGeneratedId} is already used!`, 'error');
                    document.getElementById('id-info').innerHTML += '<br><span style="color: #ff4444;">‚ùå USED</span>';
                    log('üîÑ Generating new ID...', 'warning');
                    await generateTournamentId();
                }
                
            } catch (error) {
                log(`‚úÖ Tournament ID ${currentGeneratedId} appears available (error suggests unused)`, 'success');
                document.getElementById('id-info').innerHTML += '<br><span style="color: #00ff88;">‚úÖ LIKELY AVAILABLE</span>';
            }
        }

        async function smartStartTournament() {
            try {
                if (!connected) {
                    await connectAdmin();
                    if (!connected) return;
                }

                // Generate ID if not already done
                if (!currentGeneratedId) {
                    await generateTournamentId();
                }

                const entryFee = document.getElementById('entry-fee').value;
                const duration = parseInt(document.getElementById('duration').value);

                log(`üöÄ Starting tournament with AUTO-GENERATED ID ${currentGeneratedId}...`);
                log(`üìã Parameters: Fee=${entryFee} PHRS, Duration=${duration}s`);
                
                // Use the startTournament method with auto-generated ID
                const txHash = await tournamentManager.startTournament(currentGeneratedId, entryFee, duration);
                
                log(`üéâ TOURNAMENT STARTED SUCCESSFULLY!`, 'success');
                log(`üìÑ Tournament ID: ${currentGeneratedId}`, 'success');
                log(`üìÑ Transaction: ${txHash}`, 'success');
                log(`üéØ Players can now register for tournament ${currentGeneratedId}!`, 'success');
                
                // Update config file recommendation
                log(`üí° Update tournament-config.js DEFAULT_TOURNAMENT_ID to: ${currentGeneratedId}`, 'warning');
                
                // Clear the generated ID for next use
                currentGeneratedId = null;
                document.getElementById('generated-id').style.display = 'none';
                
            } catch (error) {
                log(`‚ùå Smart tournament start failed: ${error.message}`, 'error');
            }
        }

        async function startWithManualId() {
            try {
                if (!connected) {
                    await connectAdmin();
                    if (!connected) return;
                }

                const manualId = parseInt(document.getElementById('manual-id').value);
                if (!manualId || manualId <= 0) {
                    throw new Error('Enter a valid manual Tournament ID');
                }

                const entryFee = document.getElementById('entry-fee').value;
                const duration = parseInt(document.getElementById('duration').value);

                log(`üîß Starting tournament with MANUAL ID ${manualId}...`);
                
                const txHash = await tournamentManager.startTournament(manualId, entryFee, duration);
                
                log(`‚úÖ Manual tournament started! ID: ${manualId}, TX: ${txHash}`, 'success');
                
            } catch (error) {
                log(`‚ùå Manual tournament start failed: ${error.message}`, 'error');
            }
        }

        async function checkRunningTournaments() {
            try {
                if (!connected) {
                    await connectAdmin();
                    if (!connected) return;
                }

                log('üîç Checking running tournaments...');
                
                // Check a range of possible tournament IDs
                const idsToCheck = [1, 2, 3, 4, 5];
                if (currentGeneratedId) idsToCheck.push(currentGeneratedId);
                
                let foundActive = false;
                
                for (const id of idsToCheck) {
                    try {
                        const info = await tournamentManager.getTournamentInfo(id);
                        
                        if (info.startTime > 0) {
                            const status = info.isActive && !info.isFinished ? 'ACTIVE' : 
                                          info.isFinished ? 'FINISHED' : 'INACTIVE';
                            const color = status === 'ACTIVE' ? 'success' : 'warning';
                            
                            log(`Tournament ${id}: ${status} (${info.participantCount} participants)`, color);
                            
                            if (status === 'ACTIVE') {
                                foundActive = true;
                                const remaining = info.endTime - Math.floor(Date.now() / 1000);
                                const hours = Math.floor(remaining / 3600);
                                const minutes = Math.floor((remaining % 3600) / 60);
                                log(`   ‚è∞ Time remaining: ${hours}h ${minutes}m`);
                            }
                        }
                    } catch (e) {
                        // Skip errors for unused IDs
                    }
                }
                
                if (!foundActive) {
                    log('üìã No active tournaments found', 'warning');
                }
                
            } catch (error) {
                log(`‚ùå Check running tournaments failed: ${error.message}`, 'error');
            }
        }

        async function endTournament() {
            try {
                const tournamentId = prompt('Enter Tournament ID to end:');
                if (!tournamentId) return;
                
                if (!confirm(`Are you sure you want to END tournament ${tournamentId}?`)) {
                    return;
                }

                if (!connected) {
                    await connectAdmin();
                    if (!connected) return;
                }

                log(`üèÅ Ending tournament ${tournamentId}...`);
                
                const txHash = await tournamentManager.endTournament(parseInt(tournamentId));
                
                log(`‚úÖ Tournament ${tournamentId} ended! TX: ${txHash}`, 'success');
                
            } catch (error) {
                log(`‚ùå End tournament failed: ${error.message}`, 'error');
            }
        }

        // Auto-load
        log('üß† Smart Admin Panel loaded');
        log('üí° This panel automatically generates unique Tournament IDs');
        log('üé≤ Choose ID strategy and click "AUTO-START TOURNAMENT"');
    </script>
</body>
</html>